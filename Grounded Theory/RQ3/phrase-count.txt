lack of generalizability 19
small dataset 18
potential noise in query 8
extra burden on developers 8
subjectivity in relevance 7
vocabulary mismatch problem 6
small dataset for queries/code search 5
small dataset in query 3
potential bias in evaluation 3
java specific systems 3
biased queries for direct linking 3
one tr engine only 2
potential noise 2
potential noise in candidate apis 2
bad-identifier-naming-practices 2
low quality query issue 2
developer feedback warranted 2
software documentation warranted 2
subject to documentation quality 2
lack-of-popular-metrics 2
need-to-know-ground-truth 2
pos-tagger's-training-bias 1
potential noise in term selection 1
parameter-calibration-not-rigorous 1
full dependence on corpus 1
source terms > so terms 1
no automatic detection of hard to trace queries 1
subject-to-availability-of-attachment 1
extra burden of test case generation 1
query and api both from source code 1
is it the best way? 1
map. only tested hit@k and recall. 1
potentially high costs for ast 1
potential information overload 1
small dataset in testing 1
subjectivity in goldset 1
might be noisy for mutliple types per statement 1
lack-of-theoretical-support 1
time consuming 1
lack-of-appropriate-validation 1
term co-occurrence as relevance not validated empirically 1
developer involvement warranted in query reformulation 1
parameter config issues 1
open-source-project-only 1
potential noise in extended query 1
close corpus assumption 1
issues with low quality queries 1
subject to code change history 1
human bias in goldset 1
not-a-perfect-fitness-function 1
too many parameter tuning 1
limited-evaluation-validation 1
subject to so tags 1
weak proxy of relevance 1
impractical for use 1
small-dataset 1
subject to semantic web engine 1
out-of-vocabulary-issue 1
less impact on br_nl 1
restricted to underlying ontology 1
noisy query for code search 1
lack of scalability 1
regex based classification 1
outdated requirements 1
p(t/q) : unigram could be noisy 1
cost-benefit-analysis-needed 1
bias in goldset links 1
lack of statistical significance 1
issue with map calculation 1
replication bias 1
misclassified-pos 1
costly-ast-creation 1
lack of validation 1
nl-to-code semantic issues 1
non-substantiated assumptions 1
subject to search engines 1
subject to graph-mining method 1
limited to single entities only 1
intent-from-change-terms-unorthodox 1
tf-idf based api entity weighting 1
assumption of relevant web results 1
lack of semantic classification 1
small dataset/corpus 1
warrant up-front re-documentation of code 1
biased towards expert developers 1
lack of evaluation in application 1
well designed query needed 1
redundant api classes 1
subject to given code examples 1
potentiall infeasible for practical use due to high cost of training 1
lack of reproducibility 1
relevant segment = frequent segment acorss corpus 1
subjectivity in determining equivalent groups 1
high complexity 1
limited to software search 1
lack of usability 1
binary classifcation of quality 1
subject-to-vocabulary-mismatch-problem 1
inappropriate for cross-domain projects 1
insufficient recommendation 1
bug-chronology-not-respected 1
low quality bug report 1
pos tagging issues 1
specific-to-java-systems-only 1
bias during sentence labeling 1
learning curve in query 1
config and evaluation bias 1
potential noise in candidate terms 1
restricted query patterns 1
might fail with nested entities 1
subjectivity in query selection 1
low-quality-query-issue 1
potential-for-noisy-query-keywords 1
multi-objective-optimization 1
might only work for popular topics 1
one-subject-system-only 1
pos tagger's training bias 1
small code/feature size 1
lack of benchmark 1
developer bias in relevance 1
limited to existing code elements only 1
irrelevant statements = dissimilar acorss segments 1
false-positive-code-labeling 1
hard-to-replicate-or-reproduce 1
difficulty with noisy queries 1
training bias 1
single tr engine only 1
lack of appropriate baselines 1
query keyword independence might not hold 1
semantic agnostic approach 1
infeasible semantic similarity calculation 1
lack of validation (empirical) 1
limited to small queries 1
bad identifier naming practices 1
suggested queries could be complex to understand 1
lack-of-popular-baseline 1
lexical similarity between query and chunk might not be an ideal approach 1
lack of novelty 1
inappropriate comparison 1
code segment as query 1
no best config provided 1
oss vs closed source generalization 1
small dataset (20 queries) 1
lack of empirical evaluation 1
possibly wrong assumption of relevance 1
low-quality-bug-reports 1
noisy/irrelevant code segments 1
issues-with-szz-bug-linking 1
unstable lr model 1
pairwise api similarity matching 1
potential-noise-in-the-explanation 1
lack of appropriate metric 1
v-do does not apply always 1
high cost of ontology construction from multiple domains 1
weak theory behind ob for qr 1
lack-of-generalizability 1
limited to auxiliary tasks 1
some learning curve 1
counter-intuitive motivation 1
genetic-algorithm-costly 1
subject to developer expertise 1
hard coded thresholds for contexts 1
lack of user queries 1
weak empirical evaluation 1
subject to requirement -to -product oracle. 1
insensitive to bug report structures 1
subject-to-proprietary-dataset 1
imbalance training data 1
dimensionality reduction issue 1
mode-code differences not reflected on the approach 1
curse of dimensionality 1
precision not reported 1
regular-expression-is-error-prone 1
potential noise in terms 1
potentially unfair comparison 1
potentially high costs 1
software project naming ambiguity 1
potential noise from task contexts 1
text-based-code-similarity 1
java specfici systems 1
regular-expression-is-costly 1
potential misclassification of bug reports 1
query verbosity 1
weak fitness function 1
choice of initial query issue 1
bias with data resampling 1
possible model overfitting 1
ginseng-guided query 1
noisy/low quality query issue 1
